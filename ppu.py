from typing import List

from my_fc.flagbyte import FlagByte
from my_fc.base_class import BaseClass


class Registers:
    PPUCTRL = 0
    PPUMASK = 0
    PPUSTATUS = 0b10100000
    OAMADDR = 0
    OAMDATA = 0
    PPUSCROLL = 0
    _PPUADDR = bytearray(2)  # 16位, 高低两部分分别读取
    PPUDATA = 0
    OAMDMA = 0

    ADD_RANGE = (0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x4014)
    _PPUADDR_WRITE_COUNT = 1

    _CACHE = 0  # 内部的缓存区

    @property
    def PPUADDR(self):
        v = FlagByte(0x0)
        v[0:8] = self._PPUADDR[0]
        v[8:16] = self._PPUADDR[1]
        return v.value

    @PPUADDR.setter
    def PPUADDR(self, value):
        if self._PPUADDR_WRITE_COUNT % 2 == 0:
            self._PPUADDR[0] = value  # write low
        else:
            self._PPUADDR[1] = value  # write high
        self._PPUADDR_WRITE_COUNT += 1

    def PPUADDR_INC(self, value=1):
        v = FlagByte(0x0)
        v[0:8] = self._PPUADDR[0]
        v[8:16] = self._PPUADDR[1]
        v.value += value
        self._PPUADDR[0] = v[0:8]
        self._PPUADDR[1] = v[8:16]

    @property
    def CACHE(self):
        return self._CACHE

    @CACHE.setter
    def CACHE(self, value):
        self._CACHE = value


class PPU(BaseClass):
    def __init__(self):
        super(PPU, self).__init__()
        self._running = True

        self._memory: bytearray = bytearray(16 * 1024)
        self._registers = Registers()

    def run(self):
        while self._running:
            self.execute()

    @property
    def ADD_range(self):
        return self._registers.ADD_RANGE

    def execute(self):
        pass

    def read_address_from_cpu(self, address: int):
        '''
        PPU 地址空间
        地址	大小	描述
        0x0000-​0x0FFF	0x1000	图样表0
        0x1000-​0x1FFF	0x1000	图样表1
        0x2000-​0x23FF	0x0400	名称表 0 # 显存
        0x2400-​0x27FF	0x0400	名称表 1
        0x2800-​0x2BFF	0x0400	名称表 2
        0x2C00-​0x2FFF	0x0400	名称表 3
        0x3000-​0x3EFF	0x0F00	0x2000-​0x2EFF 镜像
        0x3F00-​0x3F1F	0x0020	调色板内存索引
        0x3F20-0x3FFF	0x00E0	0x3F00-0x3F1F 镜像

        图样表: pattern tables
        名称表: Nametables
        属性表: Attribute tables
        调色板: Palette
        :param address:

        前 8K 的地址是图样表，即 CHR-ROM，和模拟 CPU 的 Memory 时一样。我们还需要将之前ROM未处理的 CHR-ROM 放入PPU的Memory 来模拟卡带插入的过程
        之后的 4K 大小是名称表，这是 PPU 的 实际硬件内存（也就是显存），是可以修改的部分。这里储存实际的图像信息，修改这里就可以修改屏幕上显示的内容。内部还有一些细节，但此时暂时不管
        镜像
        这里涉及到「镜像」的概念
        比如上表中 0x3000-0x3EFF 是 0x2000-0x2EFF 的镜像，那么
        在访问 memory[0x3000] 时，实际访问的是 memory[0x2000]（读和写都是这样）
        在访问 memory[0x3001] 时，实际访问的是 memory[0x2001] ，以此类推
        这样， 0x3000-0x3EFF 和 0x2000-0x2EFF 一一对应
        0x3F20-0x3FFF 是 0x3F00-0x3F1F 的镜像是指
        0x3F20-0x3FFF 每 32 个字节都是 0x3F00-0x3F1F 的一个镜像
        额外需要实现的镜像
        3F10 是 3F00 的镜像
        3F14 是 3F04 的镜像
        3F18 是 3F08 的镜像
        3F1C 是 3F0C 的镜像
        调色板内存索引的部分可以不管，暂时只需要知道调色板总共大小是 0x20 = 32 ，也就是可以支持 32 种颜色即可


        Common Name	Address

        PPUCTRL	0x2000
        PPUMASK	0x2001
        PPUSTATUS	0x2002
        OAMADDR	0x2003
        OAMDATA	0x2004
        PPUSCROLL	0x2005
        PPUADDR	0x2006 # only write
        PPUDATA	0x2007
        OAMDMA	0x4014

        对上述地址进行读写，就可以读写 PPU 内部寄存器的值了
        '''
        address = self.memory_mapper(address)

        if address == 0x2007:
            if 0x3F00 <= self._registers.PPUADDR <= 0x3FFF:
                return self._memory[address]
            else:
                d = self._registers.CACHE
                self._registers.CACHE = self._memory[self._registers.PPUADDR]
                self._registers.PPUADDR_INC()
                return d

        return self._memory[address]

    def write_address_from_cpu(self, address: int, data):
        address = self.memory_mapper(address)
        if address == 0x2006:
            self._registers.PPUADDR = data
        elif address == 0x2007:
            self._memory[self._registers.PPUADDR] = data
            self._registers.PPUADDR_INC()

    def palette_table(self):  # 调色板的内存是32字节, 所以同一时刻, 屏幕上有32个颜色可用, 前16个给背景用, 后16个给精灵用
        # r g b a # 第一个像素的颜色可以有16种, 那么它的颜色的索引可以用4位来表示, 低2位的信息在图样表, 高2位的信息在属性表
        palette = [
            (0x7F, 0x7F, 0x7F, 0xFF), (0x20, 0x00, 0xB0, 0xFF), (0x28, 0x00, 0xB8, 0xFF), (0x60, 0x10, 0xA0, 0xFF),
            (0x98, 0x20, 0x78, 0xFF), (0xB0, 0x10, 0x30, 0xFF), (0xA0, 0x30, 0x00, 0xFF), (0x78, 0x40, 0x00, 0xFF),
            (0x48, 0x58, 0x00, 0xFF), (0x38, 0x68, 0x00, 0xFF), (0x38, 0x6C, 0x00, 0xFF), (0x30, 0x60, 0x40, 0xFF),
            (0x30, 0x50, 0x80, 0xFF), (0x00, 0x00, 0x00, 0xFF), (0x00, 0x00, 0x00, 0xFF), (0x00, 0x00, 0x00, 0xFF),

            (0xBC, 0xBC, 0xBC, 0xFF), (0x40, 0x60, 0xF8, 0xFF), (0x40, 0x40, 0xFF, 0xFF), (0x90, 0x40, 0xF0, 0xFF),
            (0xD8, 0x40, 0xC0, 0xFF), (0xD8, 0x40, 0x60, 0xFF), (0xE0, 0x50, 0x00, 0xFF), (0xC0, 0x70, 0x00, 0xFF),
            (0x88, 0x88, 0x00, 0xFF), (0x50, 0xA0, 0x00, 0xFF), (0x48, 0xA8, 0x10, 0xFF), (0x48, 0xA0, 0x68, 0xFF),
            (0x40, 0x90, 0xC0, 0xFF), (0x00, 0x00, 0x00, 0xFF), (0x00, 0x00, 0x00, 0xFF), (0x00, 0x00, 0x00, 0xFF),

            (0xFF, 0xFF, 0xFF, 0xFF), (0x60, 0xA0, 0xFF, 0xFF), (0x50, 0x80, 0xFF, 0xFF), (0xA0, 0x70, 0xFF, 0xFF),
            (0xF0, 0x60, 0xFF, 0xFF), (0xFF, 0x60, 0xB0, 0xFF), (0xFF, 0x78, 0x30, 0xFF), (0xFF, 0xA0, 0x00, 0xFF),
            (0xE8, 0xD0, 0x20, 0xFF), (0x98, 0xE8, 0x00, 0xFF), (0x70, 0xF0, 0x40, 0xFF), (0x70, 0xE0, 0x90, 0xFF),
            (0x60, 0xD0, 0xE0, 0xFF), (0x60, 0x60, 0x60, 0xFF), (0x00, 0x00, 0x00, 0xFF), (0x00, 0x00, 0x00, 0xFF),

            (0xFF, 0xFF, 0xFF, 0xFF), (0x90, 0xD0, 0xFF, 0xFF), (0xA0, 0xB8, 0xFF, 0xFF), (0xC0, 0xB0, 0xFF, 0xFF),
            (0xE0, 0xB0, 0xFF, 0xFF), (0xFF, 0xB8, 0xE8, 0xFF), (0xFF, 0xC8, 0xB8, 0xFF), (0xFF, 0xD8, 0xA0, 0xFF),
            (0xFF, 0xF0, 0x90, 0xFF), (0xC8, 0xF0, 0x80, 0xFF), (0xA0, 0xF0, 0xA0, 0xFF), (0xA0, 0xFF, 0xC8, 0xFF),
            (0xA0, 0xFF, 0xF0, 0xFF), (0xA0, 0xA0, 0xA0, 0xFF), (0x00, 0x00, 0x00, 0xFF), (0x00, 0x00, 0x00, 0xFF),
        ]
        return palette

    def memory_mapper(self, address):
        '''
        3F10 是 3F00 的镜像
        3F14 是 3F04 的镜像
        3F18 是 3F08 的镜像
        3F1C 是 3F0C 的镜像
        :param address:
        :return:
        '''
        mapper = {
            0x3F10: 0x3F00,
            0x3F14: 0x3F04,
            0x3F18: 0x3F08,
            0x3F1C: 0x3F0C,
        }
        if 0x3000 <= address <= 0x3eff:
            address -= 4096
            return address
        elif address in mapper:
            return mapper[address]
        else:
            return address
